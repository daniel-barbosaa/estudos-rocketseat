"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/route-recognizer";
exports.ids = ["vendor-chunks/route-recognizer"];
exports.modules = {

/***/ "(rsc)/./node_modules/route-recognizer/dist/route-recognizer.es.js":
/*!*******************************************************************!*\
  !*** ./node_modules/route-recognizer/dist/route-recognizer.es.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar createObject = Object.create;\nfunction createMap() {\n    var map = createObject(null);\n    map[\"__\"] = undefined;\n    delete map[\"__\"];\n    return map;\n}\n\nvar Target = function Target(path, matcher, delegate) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n};\nTarget.prototype.to = function to (target, callback) {\n    var delegate = this.delegate;\n    if (delegate && delegate.willAddRoute) {\n        target = delegate.willAddRoute(this.matcher.target, target);\n    }\n    this.matcher.add(this.path, target);\n    if (callback) {\n        if (callback.length === 0) {\n            throw new Error(\"You must have an argument in the function passed to `to`\");\n        }\n        this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n};\nvar Matcher = function Matcher(target) {\n    this.routes = createMap();\n    this.children = createMap();\n    this.target = target;\n};\nMatcher.prototype.add = function add (path, target) {\n    this.routes[path] = target;\n};\nMatcher.prototype.addChild = function addChild (path, target, callback, delegate) {\n    var matcher = new Matcher(target);\n    this.children[path] = matcher;\n    var match = generateMatch(path, matcher, delegate);\n    if (delegate && delegate.contextEntered) {\n        delegate.contextEntered(target, match);\n    }\n    callback(match);\n};\nfunction generateMatch(startingPath, matcher, delegate) {\n    function match(path, callback) {\n        var fullPath = startingPath + path;\n        if (callback) {\n            callback(generateMatch(fullPath, matcher, delegate));\n        }\n        else {\n            return new Target(fullPath, matcher, delegate);\n        }\n    }\n    \n    return match;\n}\nfunction addRoute(routeArray, path, handler) {\n    var len = 0;\n    for (var i = 0; i < routeArray.length; i++) {\n        len += routeArray[i].path.length;\n    }\n    path = path.substr(len);\n    var route = { path: path, handler: handler };\n    routeArray.push(route);\n}\nfunction eachRoute(baseRoute, matcher, callback, binding) {\n    var routes = matcher.routes;\n    var paths = Object.keys(routes);\n    for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        var routeArray = baseRoute.slice();\n        addRoute(routeArray, path, routes[path]);\n        var nested = matcher.children[path];\n        if (nested) {\n            eachRoute(routeArray, nested, callback, binding);\n        }\n        else {\n            callback.call(binding, routeArray);\n        }\n    }\n}\nvar map = function (callback, addRouteCallback) {\n    var matcher = new Matcher();\n    callback(generateMatch(\"\", matcher, this.delegate));\n    eachRoute([], matcher, function (routes) {\n        if (addRouteCallback) {\n            addRouteCallback(this, routes);\n        }\n        else {\n            this.add(routes);\n        }\n    }, this);\n};\n\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\n// values that are not reserved (i.e., unicode characters, emoji, etc). The reserved\n// chars are \"/\" and \"%\".\n// Safe to call multiple times on the same path.\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\nfunction normalizePath(path) {\n    return path.split(\"/\")\n        .map(normalizeSegment)\n        .join(\"/\");\n}\n// We want to ensure the characters \"%\" and \"/\" remain in percent-encoded\n// form when normalizing paths, so replace them with their encoded form after\n// decoding the rest of the path\nvar SEGMENT_RESERVED_CHARS = /%|\\//g;\nfunction normalizeSegment(segment) {\n    if (segment.length < 3 || segment.indexOf(\"%\") === -1)\n        { return segment; }\n    return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);\n}\n// We do not want to encode these characters when generating dynamic path segments\n// See https://tools.ietf.org/html/rfc3986#section-3.3\n// sub-delims: \"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"\n// others allowed by RFC 3986: \":\", \"@\"\n//\n// First encode the entire path segment, then decode any of the encoded special chars.\n//\n// The chars \"!\", \"'\", \"(\", \")\", \"*\" do not get changed by `encodeURIComponent`,\n// so the possible encoded chars are:\n// ['%24', '%26', '%2B', '%2C', '%3B', '%3D', '%3A', '%40'].\nvar PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;\nfunction encodePathSegment(str) {\n    return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);\n}\n\nvar escapeRegex = /(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\)/g;\nvar isArray = Array.isArray;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction getParam(params, key) {\n    if (typeof params !== \"object\" || params === null) {\n        throw new Error(\"You must pass an object as the second argument to `generate`.\");\n    }\n    if (!hasOwnProperty.call(params, key)) {\n        throw new Error(\"You must provide param `\" + key + \"` to `generate`.\");\n    }\n    var value = params[key];\n    var str = typeof value === \"string\" ? value : \"\" + value;\n    if (str.length === 0) {\n        throw new Error(\"You must provide a param `\" + key + \"`.\");\n    }\n    return str;\n}\nvar eachChar = [];\neachChar[0 /* Static */] = function (segment, currentState) {\n    var state = currentState;\n    var value = segment.value;\n    for (var i = 0; i < value.length; i++) {\n        var ch = value.charCodeAt(i);\n        state = state.put(ch, false, false);\n    }\n    return state;\n};\neachChar[1 /* Dynamic */] = function (_, currentState) {\n    return currentState.put(47 /* SLASH */, true, true);\n};\neachChar[2 /* Star */] = function (_, currentState) {\n    return currentState.put(-1 /* ANY */, false, true);\n};\neachChar[4 /* Epsilon */] = function (_, currentState) {\n    return currentState;\n};\nvar regex = [];\nregex[0 /* Static */] = function (segment) {\n    return segment.value.replace(escapeRegex, \"\\\\$1\");\n};\nregex[1 /* Dynamic */] = function () {\n    return \"([^/]+)\";\n};\nregex[2 /* Star */] = function () {\n    return \"(.+)\";\n};\nregex[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar generate = [];\ngenerate[0 /* Static */] = function (segment) {\n    return segment.value;\n};\ngenerate[1 /* Dynamic */] = function (segment, params) {\n    var value = getParam(params, segment.value);\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        return encodePathSegment(value);\n    }\n    else {\n        return value;\n    }\n};\ngenerate[2 /* Star */] = function (segment, params) {\n    return getParam(params, segment.value);\n};\ngenerate[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar EmptyObject = Object.freeze({});\nvar EmptyArray = Object.freeze([]);\n// The `names` will be populated with the paramter name for each dynamic/star\n// segment. `shouldDecodes` will be populated with a boolean for each dyanamic/star\n// segment, indicating whether it should be decoded during recognition.\nfunction parse(segments, route, types) {\n    // normalize route as not starting with a \"/\". Recognition will\n    // also normalize.\n    if (route.length > 0 && route.charCodeAt(0) === 47 /* SLASH */) {\n        route = route.substr(1);\n    }\n    var parts = route.split(\"/\");\n    var names = undefined;\n    var shouldDecodes = undefined;\n    for (var i = 0; i < parts.length; i++) {\n        var part = parts[i];\n        var flags = 0;\n        var type = 0;\n        if (part === \"\") {\n            type = 4 /* Epsilon */;\n        }\n        else if (part.charCodeAt(0) === 58 /* COLON */) {\n            type = 1 /* Dynamic */;\n        }\n        else if (part.charCodeAt(0) === 42 /* STAR */) {\n            type = 2 /* Star */;\n        }\n        else {\n            type = 0 /* Static */;\n        }\n        flags = 2 << type;\n        if (flags & 12 /* Named */) {\n            part = part.slice(1);\n            names = names || [];\n            names.push(part);\n            shouldDecodes = shouldDecodes || [];\n            shouldDecodes.push((flags & 4 /* Decoded */) !== 0);\n        }\n        if (flags & 14 /* Counted */) {\n            types[type]++;\n        }\n        segments.push({\n            type: type,\n            value: normalizeSegment(part)\n        });\n    }\n    return {\n        names: names || EmptyArray,\n        shouldDecodes: shouldDecodes || EmptyArray,\n    };\n}\nfunction isEqualCharSpec(spec, char, negate) {\n    return spec.char === char && spec.negate === negate;\n}\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\nvar State = function State(states, id, char, negate, repeat) {\n    this.states = states;\n    this.id = id;\n    this.char = char;\n    this.negate = negate;\n    this.nextStates = repeat ? id : null;\n    this.pattern = \"\";\n    this._regex = undefined;\n    this.handlers = undefined;\n    this.types = undefined;\n};\nState.prototype.regex = function regex$1 () {\n    if (!this._regex) {\n        this._regex = new RegExp(this.pattern);\n    }\n    return this._regex;\n};\nState.prototype.get = function get (char, negate) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (nextStates === null)\n        { return; }\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isEqualCharSpec(child, char, negate)) {\n                return child;\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isEqualCharSpec(child$1, char, negate)) {\n            return child$1;\n        }\n    }\n};\nState.prototype.put = function put (char, negate, repeat) {\n    var state;\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(char, negate)) {\n        return state;\n    }\n    // Make a new state for the character spec\n    var states = this.states;\n    state = new State(states, states.length, char, negate, repeat);\n    states[states.length] = state;\n    // Insert the new state as a child of the current state\n    if (this.nextStates == null) {\n        this.nextStates = state.id;\n    }\n    else if (isArray(this.nextStates)) {\n        this.nextStates.push(state.id);\n    }\n    else {\n        this.nextStates = [this.nextStates, state.id];\n    }\n    // Return the new state\n    return state;\n};\n// Find a list of child states matching the next character\nState.prototype.match = function match (ch) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (!nextStates)\n        { return []; }\n    var returned = [];\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isMatch(child, ch)) {\n                returned.push(child);\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isMatch(child$1, ch)) {\n            returned.push(child$1);\n        }\n    }\n    return returned;\n};\nfunction isMatch(spec, char) {\n    return spec.negate ? spec.char !== char && spec.char !== -1 /* ANY */ : spec.char === char || spec.char === -1 /* ANY */;\n}\n// This is a somewhat naive strategy, but should work in a lot of cases\n// A better strategy would properly resolve /posts/:id/new and /posts/edit/:id.\n//\n// This strategy generally prefers more static and less dynamic matching.\n// Specifically, it\n//\n//  * prefers fewer stars to more, then\n//  * prefers using stars for less of the match to more, then\n//  * prefers fewer dynamic segments to more, then\n//  * prefers more static segments to more\nfunction sortSolutions(states) {\n    return states.sort(function (a, b) {\n        var ref = a.types || [0, 0, 0];\n        var astatics = ref[0];\n        var adynamics = ref[1];\n        var astars = ref[2];\n        var ref$1 = b.types || [0, 0, 0];\n        var bstatics = ref$1[0];\n        var bdynamics = ref$1[1];\n        var bstars = ref$1[2];\n        if (astars !== bstars) {\n            return astars - bstars;\n        }\n        if (astars) {\n            if (astatics !== bstatics) {\n                return bstatics - astatics;\n            }\n            if (adynamics !== bdynamics) {\n                return bdynamics - adynamics;\n            }\n        }\n        if (adynamics !== bdynamics) {\n            return adynamics - bdynamics;\n        }\n        if (astatics !== bstatics) {\n            return bstatics - astatics;\n        }\n        return 0;\n    });\n}\nfunction recognizeChar(states, ch) {\n    var nextStates = [];\n    for (var i = 0, l = states.length; i < l; i++) {\n        var state = states[i];\n        nextStates = nextStates.concat(state.match(ch));\n    }\n    return nextStates;\n}\nvar RecognizeResults = function RecognizeResults(queryParams) {\n    this.length = 0;\n    this.queryParams = queryParams || {};\n};\n\nRecognizeResults.prototype.splice = Array.prototype.splice;\nRecognizeResults.prototype.slice = Array.prototype.slice;\nRecognizeResults.prototype.push = Array.prototype.push;\nfunction findHandler(state, originalPath, queryParams) {\n    var handlers = state.handlers;\n    var regex = state.regex();\n    if (!regex || !handlers)\n        { throw new Error(\"state not initialized\"); }\n    var captures = originalPath.match(regex);\n    var currentCapture = 1;\n    var result = new RecognizeResults(queryParams);\n    result.length = handlers.length;\n    for (var i = 0; i < handlers.length; i++) {\n        var handler = handlers[i];\n        var names = handler.names;\n        var shouldDecodes = handler.shouldDecodes;\n        var params = EmptyObject;\n        var isDynamic = false;\n        if (names !== EmptyArray && shouldDecodes !== EmptyArray) {\n            for (var j = 0; j < names.length; j++) {\n                isDynamic = true;\n                var name = names[j];\n                var capture = captures && captures[currentCapture++];\n                if (params === EmptyObject) {\n                    params = {};\n                }\n                if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {\n                    params[name] = capture && decodeURIComponent(capture);\n                }\n                else {\n                    params[name] = capture;\n                }\n            }\n        }\n        result[i] = {\n            handler: handler.handler,\n            params: params,\n            isDynamic: isDynamic\n        };\n    }\n    return result;\n}\nfunction decodeQueryParamPart(part) {\n    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n    part = part.replace(/\\+/gm, \"%20\");\n    var result;\n    try {\n        result = decodeURIComponent(part);\n    }\n    catch (error) {\n        result = \"\";\n    }\n    return result;\n}\nvar RouteRecognizer = function RouteRecognizer() {\n    this.names = createMap();\n    var states = [];\n    var state = new State(states, 0, -1 /* ANY */, true, false);\n    states[0] = state;\n    this.states = states;\n    this.rootState = state;\n};\nRouteRecognizer.prototype.add = function add (routes, options) {\n    var currentState = this.rootState;\n    var pattern = \"^\";\n    var types = [0, 0, 0];\n    var handlers = new Array(routes.length);\n    var allSegments = [];\n    var isEmpty = true;\n    var j = 0;\n    for (var i = 0; i < routes.length; i++) {\n        var route = routes[i];\n        var ref = parse(allSegments, route.path, types);\n            var names = ref.names;\n            var shouldDecodes = ref.shouldDecodes;\n        // preserve j so it points to the start of newly added segments\n        for (; j < allSegments.length; j++) {\n            var segment = allSegments[j];\n            if (segment.type === 4 /* Epsilon */) {\n                continue;\n            }\n            isEmpty = false;\n            // Add a \"/\" for the new segment\n            currentState = currentState.put(47 /* SLASH */, false, false);\n            pattern += \"/\";\n            // Add a representation of the segment to the NFA and regex\n            currentState = eachChar[segment.type](segment, currentState);\n            pattern += regex[segment.type](segment);\n        }\n        handlers[i] = {\n            handler: route.handler,\n            names: names,\n            shouldDecodes: shouldDecodes\n        };\n    }\n    if (isEmpty) {\n        currentState = currentState.put(47 /* SLASH */, false, false);\n        pattern += \"/\";\n    }\n    currentState.handlers = handlers;\n    currentState.pattern = pattern + \"$\";\n    currentState.types = types;\n    var name;\n    if (typeof options === \"object\" && options !== null && options.as) {\n        name = options.as;\n    }\n    if (name) {\n        // if (this.names[name]) {\n        //   throw new Error(\"You may not add a duplicate route named `\" + name + \"`.\");\n        // }\n        this.names[name] = {\n            segments: allSegments,\n            handlers: handlers\n        };\n    }\n};\nRouteRecognizer.prototype.handlersFor = function handlersFor (name) {\n    var route = this.names[name];\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var result = new Array(route.handlers.length);\n    for (var i = 0; i < route.handlers.length; i++) {\n        var handler = route.handlers[i];\n        result[i] = handler;\n    }\n    return result;\n};\nRouteRecognizer.prototype.hasRoute = function hasRoute (name) {\n    return !!this.names[name];\n};\nRouteRecognizer.prototype.generate = function generate$1 (name, params) {\n    var route = this.names[name];\n    var output = \"\";\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var segments = route.segments;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        if (segment.type === 4 /* Epsilon */) {\n            continue;\n        }\n        output += \"/\";\n        output += generate[segment.type](segment, params);\n    }\n    if (output.charAt(0) !== \"/\") {\n        output = \"/\" + output;\n    }\n    if (params && params.queryParams) {\n        output += this.generateQueryString(params.queryParams);\n    }\n    return output;\n};\nRouteRecognizer.prototype.generateQueryString = function generateQueryString (params) {\n    var pairs = [];\n    var keys = Object.keys(params);\n    keys.sort();\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = params[key];\n        if (value == null) {\n            continue;\n        }\n        var pair = encodeURIComponent(key);\n        if (isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n                var arrayPair = key + \"[]\" + \"=\" + encodeURIComponent(value[j]);\n                pairs.push(arrayPair);\n            }\n        }\n        else {\n            pair += \"=\" + encodeURIComponent(value);\n            pairs.push(pair);\n        }\n    }\n    if (pairs.length === 0) {\n        return \"\";\n    }\n    return \"?\" + pairs.join(\"&\");\n};\nRouteRecognizer.prototype.parseQueryString = function parseQueryString (queryString) {\n    var pairs = queryString.split(\"&\");\n    var queryParams = {};\n    for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i].split(\"=\"), key = decodeQueryParamPart(pair[0]), keyLength = key.length, isArray = false, value = (void 0);\n        if (pair.length === 1) {\n            value = \"true\";\n        }\n        else {\n            // Handle arrays\n            if (keyLength > 2 && key.slice(keyLength - 2) === \"[]\") {\n                isArray = true;\n                key = key.slice(0, keyLength - 2);\n                if (!queryParams[key]) {\n                    queryParams[key] = [];\n                }\n            }\n            value = pair[1] ? decodeQueryParamPart(pair[1]) : \"\";\n        }\n        if (isArray) {\n            queryParams[key].push(value);\n        }\n        else {\n            queryParams[key] = value;\n        }\n    }\n    return queryParams;\n};\nRouteRecognizer.prototype.recognize = function recognize (path) {\n    var results;\n    var states = [this.rootState];\n    var queryParams = {};\n    var isSlashDropped = false;\n    var hashStart = path.indexOf(\"#\");\n    if (hashStart !== -1) {\n        path = path.substr(0, hashStart);\n    }\n    var queryStart = path.indexOf(\"?\");\n    if (queryStart !== -1) {\n        var queryString = path.substr(queryStart + 1, path.length);\n        path = path.substr(0, queryStart);\n        queryParams = this.parseQueryString(queryString);\n    }\n    if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n    }\n    var originalPath = path;\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        path = normalizePath(path);\n    }\n    else {\n        path = decodeURI(path);\n        originalPath = decodeURI(originalPath);\n    }\n    var pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n        path = path.substr(0, pathLen - 1);\n        originalPath = originalPath.substr(0, originalPath.length - 1);\n        isSlashDropped = true;\n    }\n    for (var i = 0; i < path.length; i++) {\n        states = recognizeChar(states, path.charCodeAt(i));\n        if (!states.length) {\n            break;\n        }\n    }\n    var solutions = [];\n    for (var i$1 = 0; i$1 < states.length; i$1++) {\n        if (states[i$1].handlers) {\n            solutions.push(states[i$1]);\n        }\n    }\n    states = sortSolutions(solutions);\n    var state = solutions[0];\n    if (state && state.handlers) {\n        // if a trailing slash was dropped and a star segment is the last segment\n        // specified, put the trailing slash back\n        if (isSlashDropped && state.pattern && state.pattern.slice(-5) === \"(.+)$\") {\n            originalPath = originalPath + \"/\";\n        }\n        results = findHandler(state, originalPath, queryParams);\n    }\n    return results;\n};\nRouteRecognizer.VERSION = \"0.3.4\";\n// Set to false to opt-out of encoding and decoding path segments.\n// See https://github.com/tildeio/route-recognizer/pull/55\nRouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS = true;\nRouteRecognizer.Normalizer = {\n    normalizeSegment: normalizeSegment, normalizePath: normalizePath, encodePathSegment: encodePathSegment\n};\nRouteRecognizer.prototype.map = map;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteRecognizer);\n\n//# sourceMappingURL=route-recognizer.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcm91dGUtcmVjb2duaXplci9kaXN0L3JvdXRlLXJlY29nbml6ZXIuZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGVBQWUsRUFBQzs7QUFFL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoZ28vLi9ub2RlX21vZHVsZXMvcm91dGUtcmVjb2duaXplci9kaXN0L3JvdXRlLXJlY29nbml6ZXIuZXMuanM/YzRlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3JlYXRlT2JqZWN0ID0gT2JqZWN0LmNyZWF0ZTtcbmZ1bmN0aW9uIGNyZWF0ZU1hcCgpIHtcbiAgICB2YXIgbWFwID0gY3JlYXRlT2JqZWN0KG51bGwpO1xuICAgIG1hcFtcIl9fXCJdID0gdW5kZWZpbmVkO1xuICAgIGRlbGV0ZSBtYXBbXCJfX1wiXTtcbiAgICByZXR1cm4gbWFwO1xufVxuXG52YXIgVGFyZ2V0ID0gZnVuY3Rpb24gVGFyZ2V0KHBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbn07XG5UYXJnZXQucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gdG8gKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlO1xuICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS53aWxsQWRkUm91dGUpIHtcbiAgICAgICAgdGFyZ2V0ID0gZGVsZWdhdGUud2lsbEFkZFJvdXRlKHRoaXMubWF0Y2hlci50YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIHRoaXMubWF0Y2hlci5hZGQodGhpcy5wYXRoLCB0YXJnZXQpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBoYXZlIGFuIGFyZ3VtZW50IGluIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYHRvYFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGNoZXIuYWRkQ2hpbGQodGhpcy5wYXRoLCB0YXJnZXQsIGNhbGxiYWNrLCB0aGlzLmRlbGVnYXRlKTtcbiAgICB9XG59O1xudmFyIE1hdGNoZXIgPSBmdW5jdGlvbiBNYXRjaGVyKHRhcmdldCkge1xuICAgIHRoaXMucm91dGVzID0gY3JlYXRlTWFwKCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNyZWF0ZU1hcCgpO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufTtcbk1hdGNoZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAocGF0aCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5yb3V0ZXNbcGF0aF0gPSB0YXJnZXQ7XG59O1xuTWF0Y2hlci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAocGF0aCwgdGFyZ2V0LCBjYWxsYmFjaywgZGVsZWdhdGUpIHtcbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKHRhcmdldCk7XG4gICAgdGhpcy5jaGlsZHJlbltwYXRoXSA9IG1hdGNoZXI7XG4gICAgdmFyIG1hdGNoID0gZ2VuZXJhdGVNYXRjaChwYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSk7XG4gICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLmNvbnRleHRFbnRlcmVkKSB7XG4gICAgICAgIGRlbGVnYXRlLmNvbnRleHRFbnRlcmVkKHRhcmdldCwgbWF0Y2gpO1xuICAgIH1cbiAgICBjYWxsYmFjayhtYXRjaCk7XG59O1xuZnVuY3Rpb24gZ2VuZXJhdGVNYXRjaChzdGFydGluZ1BhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKSB7XG4gICAgZnVuY3Rpb24gbWF0Y2gocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bGxQYXRoID0gc3RhcnRpbmdQYXRoICsgcGF0aDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhnZW5lcmF0ZU1hdGNoKGZ1bGxQYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoZnVsbFBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbWF0Y2g7XG59XG5mdW5jdGlvbiBhZGRSb3V0ZShyb3V0ZUFycmF5LCBwYXRoLCBoYW5kbGVyKSB7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3V0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbiArPSByb3V0ZUFycmF5W2ldLnBhdGgubGVuZ3RoO1xuICAgIH1cbiAgICBwYXRoID0gcGF0aC5zdWJzdHIobGVuKTtcbiAgICB2YXIgcm91dGUgPSB7IHBhdGg6IHBhdGgsIGhhbmRsZXI6IGhhbmRsZXIgfTtcbiAgICByb3V0ZUFycmF5LnB1c2gocm91dGUpO1xufVxuZnVuY3Rpb24gZWFjaFJvdXRlKGJhc2VSb3V0ZSwgbWF0Y2hlciwgY2FsbGJhY2ssIGJpbmRpbmcpIHtcbiAgICB2YXIgcm91dGVzID0gbWF0Y2hlci5yb3V0ZXM7XG4gICAgdmFyIHBhdGhzID0gT2JqZWN0LmtleXMocm91dGVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgIHZhciByb3V0ZUFycmF5ID0gYmFzZVJvdXRlLnNsaWNlKCk7XG4gICAgICAgIGFkZFJvdXRlKHJvdXRlQXJyYXksIHBhdGgsIHJvdXRlc1twYXRoXSk7XG4gICAgICAgIHZhciBuZXN0ZWQgPSBtYXRjaGVyLmNoaWxkcmVuW3BhdGhdO1xuICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgICBlYWNoUm91dGUocm91dGVBcnJheSwgbmVzdGVkLCBjYWxsYmFjaywgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGJpbmRpbmcsIHJvdXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIG1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYWRkUm91dGVDYWxsYmFjaykge1xuICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIoKTtcbiAgICBjYWxsYmFjayhnZW5lcmF0ZU1hdGNoKFwiXCIsIG1hdGNoZXIsIHRoaXMuZGVsZWdhdGUpKTtcbiAgICBlYWNoUm91dGUoW10sIG1hdGNoZXIsIGZ1bmN0aW9uIChyb3V0ZXMpIHtcbiAgICAgICAgaWYgKGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGFkZFJvdXRlQ2FsbGJhY2sodGhpcywgcm91dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHJvdXRlcyk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn07XG5cbi8vIE5vcm1hbGl6ZXMgcGVyY2VudC1lbmNvZGVkIHZhbHVlcyBpbiBgcGF0aGAgdG8gdXBwZXItY2FzZSBhbmQgZGVjb2RlcyBwZXJjZW50LWVuY29kZWRcbi8vIHZhbHVlcyB0aGF0IGFyZSBub3QgcmVzZXJ2ZWQgKGkuZS4sIHVuaWNvZGUgY2hhcmFjdGVycywgZW1vamksIGV0YykuIFRoZSByZXNlcnZlZFxuLy8gY2hhcnMgYXJlIFwiL1wiIGFuZCBcIiVcIi5cbi8vIFNhZmUgdG8gY2FsbCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwYXRoLlxuLy8gTm9ybWFsaXplcyBwZXJjZW50LWVuY29kZWQgdmFsdWVzIGluIGBwYXRoYCB0byB1cHBlci1jYXNlIGFuZCBkZWNvZGVzIHBlcmNlbnQtZW5jb2RlZFxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpXG4gICAgICAgIC5tYXAobm9ybWFsaXplU2VnbWVudClcbiAgICAgICAgLmpvaW4oXCIvXCIpO1xufVxuLy8gV2Ugd2FudCB0byBlbnN1cmUgdGhlIGNoYXJhY3RlcnMgXCIlXCIgYW5kIFwiL1wiIHJlbWFpbiBpbiBwZXJjZW50LWVuY29kZWRcbi8vIGZvcm0gd2hlbiBub3JtYWxpemluZyBwYXRocywgc28gcmVwbGFjZSB0aGVtIHdpdGggdGhlaXIgZW5jb2RlZCBmb3JtIGFmdGVyXG4vLyBkZWNvZGluZyB0aGUgcmVzdCBvZiB0aGUgcGF0aFxudmFyIFNFR01FTlRfUkVTRVJWRURfQ0hBUlMgPSAvJXxcXC8vZztcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoc2VnbWVudCkge1xuICAgIGlmIChzZWdtZW50Lmxlbmd0aCA8IDMgfHwgc2VnbWVudC5pbmRleE9mKFwiJVwiKSA9PT0gLTEpXG4gICAgICAgIHsgcmV0dXJuIHNlZ21lbnQ7IH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHNlZ21lbnQpLnJlcGxhY2UoU0VHTUVOVF9SRVNFUlZFRF9DSEFSUywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbn1cbi8vIFdlIGRvIG5vdCB3YW50IHRvIGVuY29kZSB0aGVzZSBjaGFyYWN0ZXJzIHdoZW4gZ2VuZXJhdGluZyBkeW5hbWljIHBhdGggc2VnbWVudHNcbi8vIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuM1xuLy8gc3ViLWRlbGltczogXCIhXCIsIFwiJFwiLCBcIiZcIiwgXCInXCIsIFwiKFwiLCBcIilcIiwgXCIqXCIsIFwiK1wiLCBcIixcIiwgXCI7XCIsIFwiPVwiXG4vLyBvdGhlcnMgYWxsb3dlZCBieSBSRkMgMzk4NjogXCI6XCIsIFwiQFwiXG4vL1xuLy8gRmlyc3QgZW5jb2RlIHRoZSBlbnRpcmUgcGF0aCBzZWdtZW50LCB0aGVuIGRlY29kZSBhbnkgb2YgdGhlIGVuY29kZWQgc3BlY2lhbCBjaGFycy5cbi8vXG4vLyBUaGUgY2hhcnMgXCIhXCIsIFwiJ1wiLCBcIihcIiwgXCIpXCIsIFwiKlwiIGRvIG5vdCBnZXQgY2hhbmdlZCBieSBgZW5jb2RlVVJJQ29tcG9uZW50YCxcbi8vIHNvIHRoZSBwb3NzaWJsZSBlbmNvZGVkIGNoYXJzIGFyZTpcbi8vIFsnJTI0JywgJyUyNicsICclMkInLCAnJTJDJywgJyUzQicsICclM0QnLCAnJTNBJywgJyU0MCddLlxudmFyIFBBVEhfU0VHTUVOVF9FTkNPRElOR1MgPSAvJSg/OjIoPzo0fDZ8QnxDKXwzKD86QnxEfEEpfDQwKS9nO1xuZnVuY3Rpb24gZW5jb2RlUGF0aFNlZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoUEFUSF9TRUdNRU5UX0VOQ09ESU5HUywgZGVjb2RlVVJJQ29tcG9uZW50KTtcbn1cblxudmFyIGVzY2FwZVJlZ2V4ID0gLyhcXC98XFwufFxcKnxcXCt8XFw/fFxcfHxcXCh8XFwpfFxcW3xcXF18XFx7fFxcfXxcXFxcKS9nO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGdldFBhcmFtKHBhcmFtcywga2V5KSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09IFwib2JqZWN0XCIgfHwgcGFyYW1zID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGdlbmVyYXRlYC5cIik7XG4gICAgfVxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBwYXJhbSBgXCIgKyBrZXkgKyBcImAgdG8gYGdlbmVyYXRlYC5cIik7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgIHZhciBzdHIgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IFwiXCIgKyB2YWx1ZTtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwcm92aWRlIGEgcGFyYW0gYFwiICsga2V5ICsgXCJgLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbnZhciBlYWNoQ2hhciA9IFtdO1xuZWFjaENoYXJbMCAvKiBTdGF0aWMgKi9dID0gZnVuY3Rpb24gKHNlZ21lbnQsIGN1cnJlbnRTdGF0ZSkge1xuICAgIHZhciBzdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICB2YXIgdmFsdWUgPSBzZWdtZW50LnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgc3RhdGUgPSBzdGF0ZS5wdXQoY2gsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn07XG5lYWNoQ2hhclsxIC8qIER5bmFtaWMgKi9dID0gZnVuY3Rpb24gKF8sIGN1cnJlbnRTdGF0ZSkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGUucHV0KDQ3IC8qIFNMQVNIICovLCB0cnVlLCB0cnVlKTtcbn07XG5lYWNoQ2hhclsyIC8qIFN0YXIgKi9dID0gZnVuY3Rpb24gKF8sIGN1cnJlbnRTdGF0ZSkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGUucHV0KC0xIC8qIEFOWSAqLywgZmFsc2UsIHRydWUpO1xufTtcbmVhY2hDaGFyWzQgLyogRXBzaWxvbiAqL10gPSBmdW5jdGlvbiAoXywgY3VycmVudFN0YXRlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbn07XG52YXIgcmVnZXggPSBbXTtcbnJlZ2V4WzAgLyogU3RhdGljICovXSA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQudmFsdWUucmVwbGFjZShlc2NhcGVSZWdleCwgXCJcXFxcJDFcIik7XG59O1xucmVnZXhbMSAvKiBEeW5hbWljICovXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCIoW14vXSspXCI7XG59O1xucmVnZXhbMiAvKiBTdGFyICovXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCIoLispXCI7XG59O1xucmVnZXhbNCAvKiBFcHNpbG9uICovXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIjtcbn07XG52YXIgZ2VuZXJhdGUgPSBbXTtcbmdlbmVyYXRlWzAgLyogU3RhdGljICovXSA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQudmFsdWU7XG59O1xuZ2VuZXJhdGVbMSAvKiBEeW5hbWljICovXSA9IGZ1bmN0aW9uIChzZWdtZW50LCBwYXJhbXMpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRQYXJhbShwYXJhbXMsIHNlZ21lbnQudmFsdWUpO1xuICAgIGlmIChSb3V0ZVJlY29nbml6ZXIuRU5DT0RFX0FORF9ERUNPREVfUEFUSF9TRUdNRU5UUykge1xuICAgICAgICByZXR1cm4gZW5jb2RlUGF0aFNlZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5nZW5lcmF0ZVsyIC8qIFN0YXIgKi9dID0gZnVuY3Rpb24gKHNlZ21lbnQsIHBhcmFtcykge1xuICAgIHJldHVybiBnZXRQYXJhbShwYXJhbXMsIHNlZ21lbnQudmFsdWUpO1xufTtcbmdlbmVyYXRlWzQgLyogRXBzaWxvbiAqL10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG59O1xudmFyIEVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG52YXIgRW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pO1xuLy8gVGhlIGBuYW1lc2Agd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB0aGUgcGFyYW10ZXIgbmFtZSBmb3IgZWFjaCBkeW5hbWljL3N0YXJcbi8vIHNlZ21lbnQuIGBzaG91bGREZWNvZGVzYCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGEgYm9vbGVhbiBmb3IgZWFjaCBkeWFuYW1pYy9zdGFyXG4vLyBzZWdtZW50LCBpbmRpY2F0aW5nIHdoZXRoZXIgaXQgc2hvdWxkIGJlIGRlY29kZWQgZHVyaW5nIHJlY29nbml0aW9uLlxuZnVuY3Rpb24gcGFyc2Uoc2VnbWVudHMsIHJvdXRlLCB0eXBlcykge1xuICAgIC8vIG5vcm1hbGl6ZSByb3V0ZSBhcyBub3Qgc3RhcnRpbmcgd2l0aCBhIFwiL1wiLiBSZWNvZ25pdGlvbiB3aWxsXG4gICAgLy8gYWxzbyBub3JtYWxpemUuXG4gICAgaWYgKHJvdXRlLmxlbmd0aCA+IDAgJiYgcm91dGUuY2hhckNvZGVBdCgwKSA9PT0gNDcgLyogU0xBU0ggKi8pIHtcbiAgICAgICAgcm91dGUgPSByb3V0ZS5zdWJzdHIoMSk7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IHJvdXRlLnNwbGl0KFwiL1wiKTtcbiAgICB2YXIgbmFtZXMgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHNob3VsZERlY29kZXMgPSB1bmRlZmluZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICB2YXIgZmxhZ3MgPSAwO1xuICAgICAgICB2YXIgdHlwZSA9IDA7XG4gICAgICAgIGlmIChwYXJ0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0eXBlID0gNCAvKiBFcHNpbG9uICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnQuY2hhckNvZGVBdCgwKSA9PT0gNTggLyogQ09MT04gKi8pIHtcbiAgICAgICAgICAgIHR5cGUgPSAxIC8qIER5bmFtaWMgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydC5jaGFyQ29kZUF0KDApID09PSA0MiAvKiBTVEFSICovKSB7XG4gICAgICAgICAgICB0eXBlID0gMiAvKiBTdGFyICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IDAgLyogU3RhdGljICovO1xuICAgICAgICB9XG4gICAgICAgIGZsYWdzID0gMiA8PCB0eXBlO1xuICAgICAgICBpZiAoZmxhZ3MgJiAxMiAvKiBOYW1lZCAqLykge1xuICAgICAgICAgICAgcGFydCA9IHBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICBuYW1lcyA9IG5hbWVzIHx8IFtdO1xuICAgICAgICAgICAgbmFtZXMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIHNob3VsZERlY29kZXMgPSBzaG91bGREZWNvZGVzIHx8IFtdO1xuICAgICAgICAgICAgc2hvdWxkRGVjb2Rlcy5wdXNoKChmbGFncyAmIDQgLyogRGVjb2RlZCAqLykgIT09IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDE0IC8qIENvdW50ZWQgKi8pIHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdKys7XG4gICAgICAgIH1cbiAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZVNlZ21lbnQocGFydClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVzOiBuYW1lcyB8fCBFbXB0eUFycmF5LFxuICAgICAgICBzaG91bGREZWNvZGVzOiBzaG91bGREZWNvZGVzIHx8IEVtcHR5QXJyYXksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxDaGFyU3BlYyhzcGVjLCBjaGFyLCBuZWdhdGUpIHtcbiAgICByZXR1cm4gc3BlYy5jaGFyID09PSBjaGFyICYmIHNwZWMubmVnYXRlID09PSBuZWdhdGU7XG59XG4vLyBBIFN0YXRlIGhhcyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFuZCAoYGNoYXJTcGVjYCkgYW5kIGEgbGlzdCBvZiBwb3NzaWJsZVxuLy8gc3Vic2VxdWVudCBzdGF0ZXMgKGBuZXh0U3RhdGVzYCkuXG4vL1xuLy8gSWYgYSBTdGF0ZSBpcyBhbiBhY2NlcHRpbmcgc3RhdGUsIGl0IHdpbGwgYWxzbyBoYXZlIHNldmVyYWwgYWRkaXRpb25hbFxuLy8gcHJvcGVydGllczpcbi8vXG4vLyAqIGByZWdleGA6IEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgaXMgdXNlZCB0byBleHRyYWN0IHBhcmFtZXRlcnMgZnJvbSBwYXRoc1xuLy8gICB0aGF0IHJlYWNoZWQgdGhpcyBhY2NlcHRpbmcgc3RhdGUuXG4vLyAqIGBoYW5kbGVyc2A6IEluZm9ybWF0aW9uIG9uIGhvdyB0byBjb252ZXJ0IHRoZSBsaXN0IG9mIGNhcHR1cmVzIGludG8gY2FsbHNcbi8vICAgdG8gcmVnaXN0ZXJlZCBoYW5kbGVycyB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyc1xuLy8gKiBgdHlwZXNgOiBIb3cgbWFueSBzdGF0aWMsIGR5bmFtaWMgb3Igc3RhciBzZWdtZW50cyBpbiB0aGlzIHJvdXRlLiBVc2VkIHRvXG4vLyAgIGRlY2lkZSB3aGljaCByb3V0ZSB0byB1c2UgaWYgbXVsdGlwbGUgcmVnaXN0ZXJlZCByb3V0ZXMgbWF0Y2ggYSBwYXRoLlxuLy9cbi8vIEN1cnJlbnRseSwgU3RhdGUgaXMgaW1wbGVtZW50ZWQgbmFpdmVseSBieSBsb29waW5nIG92ZXIgYG5leHRTdGF0ZXNgIGFuZFxuLy8gY29tcGFyaW5nIGEgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gYWdhaW5zdCBhIGNoYXJhY3Rlci4gQSBtb3JlIGVmZmljaWVudFxuLy8gaW1wbGVtZW50YXRpb24gd291bGQgdXNlIGEgaGFzaCBvZiBrZXlzIHBvaW50aW5nIGF0IG9uZSBvciBtb3JlIG5leHQgc3RhdGVzLlxudmFyIFN0YXRlID0gZnVuY3Rpb24gU3RhdGUoc3RhdGVzLCBpZCwgY2hhciwgbmVnYXRlLCByZXBlYXQpIHtcbiAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jaGFyID0gY2hhcjtcbiAgICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICB0aGlzLm5leHRTdGF0ZXMgPSByZXBlYXQgPyBpZCA6IG51bGw7XG4gICAgdGhpcy5wYXR0ZXJuID0gXCJcIjtcbiAgICB0aGlzLl9yZWdleCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhhbmRsZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudHlwZXMgPSB1bmRlZmluZWQ7XG59O1xuU3RhdGUucHJvdG90eXBlLnJlZ2V4ID0gZnVuY3Rpb24gcmVnZXgkMSAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZWdleCkge1xuICAgICAgICB0aGlzLl9yZWdleCA9IG5ldyBSZWdFeHAodGhpcy5wYXR0ZXJuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2V4O1xufTtcblN0YXRlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGNoYXIsIG5lZ2F0ZSkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzO1xuICAgIGlmIChuZXh0U3RhdGVzID09PSBudWxsKVxuICAgICAgICB7IHJldHVybjsgfVxuICAgIGlmIChpc0FycmF5KG5leHRTdGF0ZXMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcyQxLnN0YXRlc1tuZXh0U3RhdGVzW2ldXTtcbiAgICAgICAgICAgIGlmIChpc0VxdWFsQ2hhclNwZWMoY2hpbGQsIGNoYXIsIG5lZ2F0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZCQxID0gdGhpcy5zdGF0ZXNbbmV4dFN0YXRlc107XG4gICAgICAgIGlmIChpc0VxdWFsQ2hhclNwZWMoY2hpbGQkMSwgY2hhciwgbmVnYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkJDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuU3RhdGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIHB1dCAoY2hhciwgbmVnYXRlLCByZXBlYXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgLy8gSWYgdGhlIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFscmVhZHkgZXhpc3RzIGluIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnRcbiAgICAvLyBzdGF0ZSwganVzdCByZXR1cm4gdGhhdCBzdGF0ZS5cbiAgICBpZiAoc3RhdGUgPSB0aGlzLmdldChjaGFyLCBuZWdhdGUpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLy8gTWFrZSBhIG5ldyBzdGF0ZSBmb3IgdGhlIGNoYXJhY3RlciBzcGVjXG4gICAgdmFyIHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuICAgIHN0YXRlID0gbmV3IFN0YXRlKHN0YXRlcywgc3RhdGVzLmxlbmd0aCwgY2hhciwgbmVnYXRlLCByZXBlYXQpO1xuICAgIHN0YXRlc1tzdGF0ZXMubGVuZ3RoXSA9IHN0YXRlO1xuICAgIC8vIEluc2VydCB0aGUgbmV3IHN0YXRlIGFzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICBpZiAodGhpcy5uZXh0U3RhdGVzID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5uZXh0U3RhdGVzID0gc3RhdGUuaWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodGhpcy5uZXh0U3RhdGVzKSkge1xuICAgICAgICB0aGlzLm5leHRTdGF0ZXMucHVzaChzdGF0ZS5pZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRTdGF0ZXMgPSBbdGhpcy5uZXh0U3RhdGVzLCBzdGF0ZS5pZF07XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgbmV3IHN0YXRlXG4gICAgcmV0dXJuIHN0YXRlO1xufTtcbi8vIEZpbmQgYSBsaXN0IG9mIGNoaWxkIHN0YXRlcyBtYXRjaGluZyB0aGUgbmV4dCBjaGFyYWN0ZXJcblN0YXRlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChjaCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzO1xuICAgIGlmICghbmV4dFN0YXRlcylcbiAgICAgICAgeyByZXR1cm4gW107IH1cbiAgICB2YXIgcmV0dXJuZWQgPSBbXTtcbiAgICBpZiAoaXNBcnJheShuZXh0U3RhdGVzKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMkMS5zdGF0ZXNbbmV4dFN0YXRlc1tpXV07XG4gICAgICAgICAgICBpZiAoaXNNYXRjaChjaGlsZCwgY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZCQxID0gdGhpcy5zdGF0ZXNbbmV4dFN0YXRlc107XG4gICAgICAgIGlmIChpc01hdGNoKGNoaWxkJDEsIGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuZWQucHVzaChjaGlsZCQxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuZWQ7XG59O1xuZnVuY3Rpb24gaXNNYXRjaChzcGVjLCBjaGFyKSB7XG4gICAgcmV0dXJuIHNwZWMubmVnYXRlID8gc3BlYy5jaGFyICE9PSBjaGFyICYmIHNwZWMuY2hhciAhPT0gLTEgLyogQU5ZICovIDogc3BlYy5jaGFyID09PSBjaGFyIHx8IHNwZWMuY2hhciA9PT0gLTEgLyogQU5ZICovO1xufVxuLy8gVGhpcyBpcyBhIHNvbWV3aGF0IG5haXZlIHN0cmF0ZWd5LCBidXQgc2hvdWxkIHdvcmsgaW4gYSBsb3Qgb2YgY2FzZXNcbi8vIEEgYmV0dGVyIHN0cmF0ZWd5IHdvdWxkIHByb3Blcmx5IHJlc29sdmUgL3Bvc3RzLzppZC9uZXcgYW5kIC9wb3N0cy9lZGl0LzppZC5cbi8vXG4vLyBUaGlzIHN0cmF0ZWd5IGdlbmVyYWxseSBwcmVmZXJzIG1vcmUgc3RhdGljIGFuZCBsZXNzIGR5bmFtaWMgbWF0Y2hpbmcuXG4vLyBTcGVjaWZpY2FsbHksIGl0XG4vL1xuLy8gICogcHJlZmVycyBmZXdlciBzdGFycyB0byBtb3JlLCB0aGVuXG4vLyAgKiBwcmVmZXJzIHVzaW5nIHN0YXJzIGZvciBsZXNzIG9mIHRoZSBtYXRjaCB0byBtb3JlLCB0aGVuXG4vLyAgKiBwcmVmZXJzIGZld2VyIGR5bmFtaWMgc2VnbWVudHMgdG8gbW9yZSwgdGhlblxuLy8gICogcHJlZmVycyBtb3JlIHN0YXRpYyBzZWdtZW50cyB0byBtb3JlXG5mdW5jdGlvbiBzb3J0U29sdXRpb25zKHN0YXRlcykge1xuICAgIHJldHVybiBzdGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcmVmID0gYS50eXBlcyB8fCBbMCwgMCwgMF07XG4gICAgICAgIHZhciBhc3RhdGljcyA9IHJlZlswXTtcbiAgICAgICAgdmFyIGFkeW5hbWljcyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGFzdGFycyA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gYi50eXBlcyB8fCBbMCwgMCwgMF07XG4gICAgICAgIHZhciBic3RhdGljcyA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgYmR5bmFtaWNzID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBic3RhcnMgPSByZWYkMVsyXTtcbiAgICAgICAgaWYgKGFzdGFycyAhPT0gYnN0YXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0YXJzIC0gYnN0YXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3RhcnMpIHtcbiAgICAgICAgICAgIGlmIChhc3RhdGljcyAhPT0gYnN0YXRpY3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnN0YXRpY3MgLSBhc3RhdGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZHluYW1pY3MgIT09IGJkeW5hbWljcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZHluYW1pY3MgLSBhZHluYW1pY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkeW5hbWljcyAhPT0gYmR5bmFtaWNzKSB7XG4gICAgICAgICAgICByZXR1cm4gYWR5bmFtaWNzIC0gYmR5bmFtaWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3RhdGljcyAhPT0gYnN0YXRpY3MpIHtcbiAgICAgICAgICAgIHJldHVybiBic3RhdGljcyAtIGFzdGF0aWNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVjb2duaXplQ2hhcihzdGF0ZXMsIGNoKSB7XG4gICAgdmFyIG5leHRTdGF0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVzW2ldO1xuICAgICAgICBuZXh0U3RhdGVzID0gbmV4dFN0YXRlcy5jb25jYXQoc3RhdGUubWF0Y2goY2gpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRTdGF0ZXM7XG59XG52YXIgUmVjb2duaXplUmVzdWx0cyA9IGZ1bmN0aW9uIFJlY29nbml6ZVJlc3VsdHMocXVlcnlQYXJhbXMpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zIHx8IHt9O1xufTtcblxuUmVjb2duaXplUmVzdWx0cy5wcm90b3R5cGUuc3BsaWNlID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcblJlY29nbml6ZVJlc3VsdHMucHJvdG90eXBlLnNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuUmVjb2duaXplUmVzdWx0cy5wcm90b3R5cGUucHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuZnVuY3Rpb24gZmluZEhhbmRsZXIoc3RhdGUsIG9yaWdpbmFsUGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBzdGF0ZS5oYW5kbGVycztcbiAgICB2YXIgcmVnZXggPSBzdGF0ZS5yZWdleCgpO1xuICAgIGlmICghcmVnZXggfHwgIWhhbmRsZXJzKVxuICAgICAgICB7IHRocm93IG5ldyBFcnJvcihcInN0YXRlIG5vdCBpbml0aWFsaXplZFwiKTsgfVxuICAgIHZhciBjYXB0dXJlcyA9IG9yaWdpbmFsUGF0aC5tYXRjaChyZWdleCk7XG4gICAgdmFyIGN1cnJlbnRDYXB0dXJlID0gMTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFJlY29nbml6ZVJlc3VsdHMocXVlcnlQYXJhbXMpO1xuICAgIHJlc3VsdC5sZW5ndGggPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2ldO1xuICAgICAgICB2YXIgbmFtZXMgPSBoYW5kbGVyLm5hbWVzO1xuICAgICAgICB2YXIgc2hvdWxkRGVjb2RlcyA9IGhhbmRsZXIuc2hvdWxkRGVjb2RlcztcbiAgICAgICAgdmFyIHBhcmFtcyA9IEVtcHR5T2JqZWN0O1xuICAgICAgICB2YXIgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChuYW1lcyAhPT0gRW1wdHlBcnJheSAmJiBzaG91bGREZWNvZGVzICE9PSBFbXB0eUFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gY2FwdHVyZXMgJiYgY2FwdHVyZXNbY3VycmVudENhcHR1cmUrK107XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcyA9PT0gRW1wdHlPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChSb3V0ZVJlY29nbml6ZXIuRU5DT0RFX0FORF9ERUNPREVfUEFUSF9TRUdNRU5UUyAmJiBzaG91bGREZWNvZGVzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IGNhcHR1cmUgJiYgZGVjb2RlVVJJQ29tcG9uZW50KGNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW25hbWVdID0gY2FwdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldID0ge1xuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlci5oYW5kbGVyLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpc0R5bmFtaWM6IGlzRHluYW1pY1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFydCkge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvaW50ZXJhY3QvZm9ybXMuaHRtbCNoLTE3LjEzLjQuMVxuICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKy9nbSwgXCIlMjBcIik7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBkZWNvZGVVUklDb21wb25lbnQocGFydCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFJvdXRlUmVjb2duaXplciA9IGZ1bmN0aW9uIFJvdXRlUmVjb2duaXplcigpIHtcbiAgICB0aGlzLm5hbWVzID0gY3JlYXRlTWFwKCk7XG4gICAgdmFyIHN0YXRlcyA9IFtdO1xuICAgIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShzdGF0ZXMsIDAsIC0xIC8qIEFOWSAqLywgdHJ1ZSwgZmFsc2UpO1xuICAgIHN0YXRlc1swXSA9IHN0YXRlO1xuICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgIHRoaXMucm9vdFN0YXRlID0gc3RhdGU7XG59O1xuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHJvdXRlcywgb3B0aW9ucykge1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLnJvb3RTdGF0ZTtcbiAgICB2YXIgcGF0dGVybiA9IFwiXlwiO1xuICAgIHZhciB0eXBlcyA9IFswLCAwLCAwXTtcbiAgICB2YXIgaGFuZGxlcnMgPSBuZXcgQXJyYXkocm91dGVzLmxlbmd0aCk7XG4gICAgdmFyIGFsbFNlZ21lbnRzID0gW107XG4gICAgdmFyIGlzRW1wdHkgPSB0cnVlO1xuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV07XG4gICAgICAgIHZhciByZWYgPSBwYXJzZShhbGxTZWdtZW50cywgcm91dGUucGF0aCwgdHlwZXMpO1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gcmVmLm5hbWVzO1xuICAgICAgICAgICAgdmFyIHNob3VsZERlY29kZXMgPSByZWYuc2hvdWxkRGVjb2RlcztcbiAgICAgICAgLy8gcHJlc2VydmUgaiBzbyBpdCBwb2ludHMgdG8gdGhlIHN0YXJ0IG9mIG5ld2x5IGFkZGVkIHNlZ21lbnRzXG4gICAgICAgIGZvciAoOyBqIDwgYWxsU2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gYWxsU2VnbWVudHNbal07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC50eXBlID09PSA0IC8qIEVwc2lsb24gKi8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEFkZCBhIFwiL1wiIGZvciB0aGUgbmV3IHNlZ21lbnRcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoNDcgLyogU0xBU0ggKi8sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IFwiL1wiO1xuICAgICAgICAgICAgLy8gQWRkIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlZ21lbnQgdG8gdGhlIE5GQSBhbmQgcmVnZXhcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGVhY2hDaGFyW3NlZ21lbnQudHlwZV0oc2VnbWVudCwgY3VycmVudFN0YXRlKTtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gcmVnZXhbc2VnbWVudC50eXBlXShzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyc1tpXSA9IHtcbiAgICAgICAgICAgIGhhbmRsZXI6IHJvdXRlLmhhbmRsZXIsXG4gICAgICAgICAgICBuYW1lczogbmFtZXMsXG4gICAgICAgICAgICBzaG91bGREZWNvZGVzOiBzaG91bGREZWNvZGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoNDcgLyogU0xBU0ggKi8sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHBhdHRlcm4gKz0gXCIvXCI7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZS5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIGN1cnJlbnRTdGF0ZS5wYXR0ZXJuID0gcGF0dGVybiArIFwiJFwiO1xuICAgIGN1cnJlbnRTdGF0ZS50eXBlcyA9IHR5cGVzO1xuICAgIHZhciBuYW1lO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMuYXMpIHtcbiAgICAgICAgbmFtZSA9IG9wdGlvbnMuYXM7XG4gICAgfVxuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIC8vIGlmICh0aGlzLm5hbWVzW25hbWVdKSB7XG4gICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG1heSBub3QgYWRkIGEgZHVwbGljYXRlIHJvdXRlIG5hbWVkIGBcIiArIG5hbWUgKyBcImAuXCIpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMubmFtZXNbbmFtZV0gPSB7XG4gICAgICAgICAgICBzZWdtZW50czogYWxsU2VnbWVudHMsXG4gICAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnNcbiAgICAgICAgfTtcbiAgICB9XG59O1xuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5oYW5kbGVyc0ZvciA9IGZ1bmN0aW9uIGhhbmRsZXJzRm9yIChuYW1lKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocm91dGUuaGFuZGxlcnMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLmhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gcm91dGUuaGFuZGxlcnNbaV07XG4gICAgICAgIHJlc3VsdFtpXSA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5oYXNSb3V0ZSA9IGZ1bmN0aW9uIGhhc1JvdXRlIChuYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5uYW1lc1tuYW1lXTtcbn07XG5Sb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUkMSAobmFtZSwgcGFyYW1zKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgfVxuICAgIHZhciBzZWdtZW50cyA9IHJvdXRlLnNlZ21lbnRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHNlZ21lbnQudHlwZSA9PT0gNCAvKiBFcHNpbG9uICovKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgKz0gXCIvXCI7XG4gICAgICAgIG91dHB1dCArPSBnZW5lcmF0ZVtzZWdtZW50LnR5cGVdKHNlZ21lbnQsIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChvdXRwdXQuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBvdXRwdXQgPSBcIi9cIiArIG91dHB1dDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgb3V0cHV0ICs9IHRoaXMuZ2VuZXJhdGVRdWVyeVN0cmluZyhwYXJhbXMucXVlcnlQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuZ2VuZXJhdGVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uIGdlbmVyYXRlUXVlcnlTdHJpbmcgKHBhcmFtcykge1xuICAgIHZhciBwYWlycyA9IFtdO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKTtcbiAgICBrZXlzLnNvcnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaXIgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5UGFpciA9IGtleSArIFwiW11cIiArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKGFycmF5UGFpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYWlyICs9IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiP1wiICsgcGFpcnMuam9pbihcIiZcIik7XG59O1xuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5wYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyAocXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGFpcnMgPSBxdWVyeVN0cmluZy5zcGxpdChcIiZcIik7XG4gICAgdmFyIHF1ZXJ5UGFyYW1zID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KFwiPVwiKSwga2V5ID0gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFpclswXSksIGtleUxlbmd0aCA9IGtleS5sZW5ndGgsIGlzQXJyYXkgPSBmYWxzZSwgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKHBhaXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwidHJ1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGFycmF5c1xuICAgICAgICAgICAgaWYgKGtleUxlbmd0aCA+IDIgJiYga2V5LnNsaWNlKGtleUxlbmd0aCAtIDIpID09PSBcIltdXCIpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc2xpY2UoMCwga2V5TGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeVBhcmFtc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV0gPyBkZWNvZGVRdWVyeVBhcmFtUGFydChwYWlyWzFdKSA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5UGFyYW1zO1xufTtcblJvdXRlUmVjb2duaXplci5wcm90b3R5cGUucmVjb2duaXplID0gZnVuY3Rpb24gcmVjb2duaXplIChwYXRoKSB7XG4gICAgdmFyIHJlc3VsdHM7XG4gICAgdmFyIHN0YXRlcyA9IFt0aGlzLnJvb3RTdGF0ZV07XG4gICAgdmFyIHF1ZXJ5UGFyYW1zID0ge307XG4gICAgdmFyIGlzU2xhc2hEcm9wcGVkID0gZmFsc2U7XG4gICAgdmFyIGhhc2hTdGFydCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hTdGFydCk7XG4gICAgfVxuICAgIHZhciBxdWVyeVN0YXJ0ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAocXVlcnlTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcGF0aC5zdWJzdHIocXVlcnlTdGFydCArIDEsIHBhdGgubGVuZ3RoKTtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHF1ZXJ5U3RhcnQpO1xuICAgICAgICBxdWVyeVBhcmFtcyA9IHRoaXMucGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZyk7XG4gICAgfVxuICAgIGlmIChwYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aCA9IFwiL1wiICsgcGF0aDtcbiAgICB9XG4gICAgdmFyIG9yaWdpbmFsUGF0aCA9IHBhdGg7XG4gICAgaWYgKFJvdXRlUmVjb2duaXplci5FTkNPREVfQU5EX0RFQ09ERV9QQVRIX1NFR01FTlRTKSB7XG4gICAgICAgIHBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcbiAgICAgICAgb3JpZ2luYWxQYXRoID0gZGVjb2RlVVJJKG9yaWdpbmFsUGF0aCk7XG4gICAgfVxuICAgIHZhciBwYXRoTGVuID0gcGF0aC5sZW5ndGg7XG4gICAgaWYgKHBhdGhMZW4gPiAxICYmIHBhdGguY2hhckF0KHBhdGhMZW4gLSAxKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGhMZW4gLSAxKTtcbiAgICAgICAgb3JpZ2luYWxQYXRoID0gb3JpZ2luYWxQYXRoLnN1YnN0cigwLCBvcmlnaW5hbFBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlzU2xhc2hEcm9wcGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlcyA9IHJlY29nbml6ZUNoYXIoc3RhdGVzLCBwYXRoLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBpZiAoIXN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzdGF0ZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICBpZiAoc3RhdGVzW2kkMV0uaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKHN0YXRlc1tpJDFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZXMgPSBzb3J0U29sdXRpb25zKHNvbHV0aW9ucyk7XG4gICAgdmFyIHN0YXRlID0gc29sdXRpb25zWzBdO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5oYW5kbGVycykge1xuICAgICAgICAvLyBpZiBhIHRyYWlsaW5nIHNsYXNoIHdhcyBkcm9wcGVkIGFuZCBhIHN0YXIgc2VnbWVudCBpcyB0aGUgbGFzdCBzZWdtZW50XG4gICAgICAgIC8vIHNwZWNpZmllZCwgcHV0IHRoZSB0cmFpbGluZyBzbGFzaCBiYWNrXG4gICAgICAgIGlmIChpc1NsYXNoRHJvcHBlZCAmJiBzdGF0ZS5wYXR0ZXJuICYmIHN0YXRlLnBhdHRlcm4uc2xpY2UoLTUpID09PSBcIiguKykkXCIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsUGF0aCA9IG9yaWdpbmFsUGF0aCArIFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMgPSBmaW5kSGFuZGxlcihzdGF0ZSwgb3JpZ2luYWxQYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufTtcblJvdXRlUmVjb2duaXplci5WRVJTSU9OID0gXCIwLjMuNFwiO1xuLy8gU2V0IHRvIGZhbHNlIHRvIG9wdC1vdXQgb2YgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHBhdGggc2VnbWVudHMuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcm91dGUtcmVjb2duaXplci9wdWxsLzU1XG5Sb3V0ZVJlY29nbml6ZXIuRU5DT0RFX0FORF9ERUNPREVfUEFUSF9TRUdNRU5UUyA9IHRydWU7XG5Sb3V0ZVJlY29nbml6ZXIuTm9ybWFsaXplciA9IHtcbiAgICBub3JtYWxpemVTZWdtZW50OiBub3JtYWxpemVTZWdtZW50LCBub3JtYWxpemVQYXRoOiBub3JtYWxpemVQYXRoLCBlbmNvZGVQYXRoU2VnbWVudDogZW5jb2RlUGF0aFNlZ21lbnRcbn07XG5Sb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLm1hcCA9IG1hcDtcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVSZWNvZ25pemVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1yZWNvZ25pemVyLmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/route-recognizer/dist/route-recognizer.es.js\n");

/***/ })

};
;
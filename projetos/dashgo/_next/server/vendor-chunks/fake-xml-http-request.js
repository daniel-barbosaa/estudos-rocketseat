"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fake-xml-http-request";
exports.ids = ["vendor-chunks/fake-xml-http-request"];
exports.modules = {

/***/ "(rsc)/./node_modules/fake-xml-http-request/src/fake-xml-http-request.js":
/*!*************************************************************************!*\
  !*** ./node_modules/fake-xml-http-request/src/fake-xml-http-request.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Minimal Event interface implementation\n *\n * Original implementation by Sven Fuchs: https://gist.github.com/995028\n * Modifications and tests by Christian Johansen.\n *\n * @author Sven Fuchs (svenfuchs@artweb-design.de)\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2011 Sven Fuchs, Christian Johansen\n */\n\nvar _Event = function Event(type, bubbles, cancelable, target) {\n  this.type = type;\n  this.bubbles = bubbles;\n  this.cancelable = cancelable;\n  this.target = target;\n};\n\n_Event.prototype = {\n  stopPropagation: function () {},\n  preventDefault: function () {\n    this.defaultPrevented = true;\n  }\n};\n\n/*\n  Used to set the statusText property of an xhr object\n*/\nvar httpStatusCodes = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  300: \"Multiple Choice\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Request Entity Too Large\",\n  414: \"Request-URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Requested Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  422: \"Unprocessable Entity\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\"\n};\n\n\n/*\n  Cross-browser XML parsing. Used to turn\n  XML responses into Document objects\n  Borrowed from JSpec\n*/\nfunction parseXML(text) {\n  var xmlDoc;\n\n  if (typeof DOMParser != \"undefined\") {\n    var parser = new DOMParser();\n    xmlDoc = parser.parseFromString(text, \"text/xml\");\n  } else {\n    xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n    xmlDoc.async = \"false\";\n    xmlDoc.loadXML(text);\n  }\n\n  return xmlDoc;\n}\n\n/*\n  Without mocking, the native XMLHttpRequest object will throw\n  an error when attempting to set these headers. We match this behavior.\n*/\nvar unsafeHeaders = {\n  \"Accept-Charset\": true,\n  \"Accept-Encoding\": true,\n  \"Connection\": true,\n  \"Content-Length\": true,\n  \"Cookie\": true,\n  \"Cookie2\": true,\n  \"Content-Transfer-Encoding\": true,\n  \"Date\": true,\n  \"Expect\": true,\n  \"Host\": true,\n  \"Keep-Alive\": true,\n  \"Referer\": true,\n  \"TE\": true,\n  \"Trailer\": true,\n  \"Transfer-Encoding\": true,\n  \"Upgrade\": true,\n  \"User-Agent\": true,\n  \"Via\": true\n};\n\n/*\n  Adds an \"event\" onto the fake xhr object\n  that just calls the same-named method. This is\n  in case a library adds callbacks for these events.\n*/\nfunction _addEventListener(eventName, xhr){\n  xhr.addEventListener(eventName, function (event) {\n    var listener = xhr[\"on\" + eventName];\n\n    if (listener && typeof listener == \"function\") {\n      listener.call(event.target, event);\n    }\n  });\n}\n\nfunction EventedObject() {\n  this._eventListeners = {};\n  var events = [\"loadstart\", \"progress\", \"load\", \"abort\", \"loadend\"];\n  for (var i = events.length - 1; i >= 0; i--) {\n    _addEventListener(events[i], this);\n  }\n};\n\nEventedObject.prototype = {\n  /*\n    Duplicates the behavior of native XMLHttpRequest's addEventListener function\n  */\n  addEventListener: function addEventListener(event, listener) {\n    this._eventListeners[event] = this._eventListeners[event] || [];\n    this._eventListeners[event].push(listener);\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's removeEventListener function\n  */\n  removeEventListener: function removeEventListener(event, listener) {\n    var listeners = this._eventListeners[event] || [];\n\n    for (var i = 0, l = listeners.length; i < l; ++i) {\n      if (listeners[i] == listener) {\n        return listeners.splice(i, 1);\n      }\n    }\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's dispatchEvent function\n  */\n  dispatchEvent: function dispatchEvent(event) {\n    var type = event.type;\n    var listeners = this._eventListeners[type] || [];\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (typeof listeners[i] == \"function\") {\n        listeners[i].call(this, event);\n      } else {\n        listeners[i].handleEvent(event);\n      }\n    }\n\n    return !!event.defaultPrevented;\n  },\n\n  /*\n    Triggers an `onprogress` event with the given parameters.\n  */\n  _progress: function _progress(lengthComputable, loaded, total) {\n    var event = new _Event('progress');\n    event.target = this;\n    event.lengthComputable = lengthComputable;\n    event.loaded = loaded;\n    event.total = total;\n    this.dispatchEvent(event);\n  }\n}\n\n/*\n  Constructor for a fake window.XMLHttpRequest\n*/\nfunction FakeXMLHttpRequest() {\n  EventedObject.call(this);\n  this.readyState = FakeXMLHttpRequest.UNSENT;\n  this.requestHeaders = {};\n  this.requestBody = null;\n  this.status = 0;\n  this.statusText = \"\";\n  this.upload = new EventedObject();\n  this.onabort= null;\n  this.onerror= null;\n  this.onload= null;\n  this.onloadend= null;\n  this.onloadstart= null;\n  this.onprogress= null;\n  this.onreadystatechange= null;\n  this.ontimeout= null;\n}\n\nFakeXMLHttpRequest.prototype = new EventedObject();\n\n// These status codes are available on the native XMLHttpRequest\n// object, so we match that here in case a library is relying on them.\nFakeXMLHttpRequest.UNSENT = 0;\nFakeXMLHttpRequest.OPENED = 1;\nFakeXMLHttpRequest.HEADERS_RECEIVED = 2;\nFakeXMLHttpRequest.LOADING = 3;\nFakeXMLHttpRequest.DONE = 4;\n\nvar FakeXMLHttpRequestProto = {\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4,\n  async: true,\n  withCredentials: false,\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's open function\n  */\n  open: function open(method, url, async, username, password) {\n    this.method = method;\n    this.url = url;\n    this.async = typeof async == \"boolean\" ? async : true;\n    this.username = username;\n    this.password = password;\n    this.responseText = null;\n    this.response = this.responseText;\n    this.responseXML = null;\n    this.responseURL = url;\n    this.requestHeaders = {};\n    this.sendFlag = false;\n    this._readyStateChange(FakeXMLHttpRequest.OPENED);\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's setRequestHeader function\n  */\n  setRequestHeader: function setRequestHeader(header, value) {\n    verifyState(this);\n\n    if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {\n      throw new Error(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n    }\n\n    if (this.requestHeaders[header]) {\n      this.requestHeaders[header] += \",\" + value;\n    } else {\n      this.requestHeaders[header] = value;\n    }\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's send function\n  */\n  send: function send(data) {\n    verifyState(this);\n\n    if (!/^(get|head)$/i.test(this.method)) {\n      var hasContentTypeHeader = false\n\n      Object.keys(this.requestHeaders).forEach(function (key) {\n        if (key.toLowerCase() === 'content-type') {\n          hasContentTypeHeader = true;\n        }\n      });\n\n      if (!hasContentTypeHeader && !(data || '').toString().match('FormData')) {\n        this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n\n      this.requestBody = data;\n    }\n\n    this.errorFlag = false;\n    this.sendFlag = this.async;\n    this._readyStateChange(FakeXMLHttpRequest.OPENED);\n\n    if (typeof this.onSend == \"function\") {\n      this.onSend(this);\n    }\n\n    this.dispatchEvent(new _Event(\"loadstart\", false, false, this));\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's abort function\n  */\n  abort: function abort() {\n    this.aborted = true;\n    this.responseText = null;\n    this.response = this.responseText;\n    this.errorFlag = true;\n    this.requestHeaders = {};\n\n    this.dispatchEvent(new _Event(\"abort\", false, false, this));\n\n    if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {\n      this._readyStateChange(FakeXMLHttpRequest.UNSENT);\n      this.sendFlag = false;\n    }\n\n    if (typeof this.onerror === \"function\") {\n      this.onerror();\n    }\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's getResponseHeader function\n  */\n  getResponseHeader: function getResponseHeader(header) {\n    if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n      return null;\n    }\n\n    if (/^Set-Cookie2?$/i.test(header)) {\n      return null;\n    }\n\n    header = header.toLowerCase();\n\n    for (var h in this.responseHeaders) {\n      if (h.toLowerCase() == header) {\n        return this.responseHeaders[h];\n      }\n    }\n\n    return null;\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's getAllResponseHeaders function\n  */\n  getAllResponseHeaders: function getAllResponseHeaders() {\n    if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n      return \"\";\n    }\n\n    var headers = \"\";\n\n    for (var header in this.responseHeaders) {\n      if (this.responseHeaders.hasOwnProperty(header) && !/^Set-Cookie2?$/i.test(header)) {\n        headers += header + \": \" + this.responseHeaders[header] + \"\\r\\n\";\n      }\n    }\n\n    return headers;\n  },\n\n  /*\n   Duplicates the behavior of native XMLHttpRequest's overrideMimeType function\n   */\n  overrideMimeType: function overrideMimeType(mimeType) {\n    if (typeof mimeType === \"string\") {\n      this.forceMimeType = mimeType.toLowerCase();\n    }\n  },\n\n\n  /*\n    Places a FakeXMLHttpRequest object into the passed\n    state.\n  */\n  _readyStateChange: function _readyStateChange(state) {\n    this.readyState = state;\n\n    if (typeof this.onreadystatechange == \"function\") {\n      this.onreadystatechange(new _Event(\"readystatechange\"));\n    }\n\n    this.dispatchEvent(new _Event(\"readystatechange\"));\n\n    if (this.readyState == FakeXMLHttpRequest.DONE) {\n      this.dispatchEvent(new _Event(\"load\", false, false, this));\n    }\n    if (this.readyState == FakeXMLHttpRequest.UNSENT || this.readyState == FakeXMLHttpRequest.DONE) {\n      this.dispatchEvent(new _Event(\"loadend\", false, false, this));\n    }\n  },\n\n\n  /*\n    Sets the FakeXMLHttpRequest object's response headers and\n    places the object into readyState 2\n  */\n  _setResponseHeaders: function _setResponseHeaders(headers) {\n    this.responseHeaders = {};\n\n    for (var header in headers) {\n      if (headers.hasOwnProperty(header)) {\n          this.responseHeaders[header] = headers[header];\n      }\n    }\n\n    if (this.forceMimeType) {\n      this.responseHeaders['Content-Type'] = this.forceMimeType;\n    }\n\n    if (this.async) {\n      this._readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\n    } else {\n      this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;\n    }\n  },\n\n  /*\n    Sets the FakeXMLHttpRequest object's response body and\n    if body text is XML, sets responseXML to parsed document\n    object\n  */\n  _setResponseBody: function _setResponseBody(body) {\n    verifyRequestSent(this);\n    verifyHeadersReceived(this);\n    verifyResponseBodyType(body);\n\n    var chunkSize = this.chunkSize || 10;\n    var index = 0;\n    this.responseText = \"\";\n    this.response = this.responseText;\n\n    do {\n      if (this.async) {\n        this._readyStateChange(FakeXMLHttpRequest.LOADING);\n      }\n\n      this.responseText += body.substring(index, index + chunkSize);\n      this.response = this.responseText;\n      index += chunkSize;\n    } while (index < body.length);\n\n    var type = this.getResponseHeader(\"Content-Type\");\n\n    if (this.responseText && (!type || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(type))) {\n      try {\n        this.responseXML = parseXML(this.responseText);\n      } catch (e) {\n        // Unable to parse XML - no biggie\n      }\n    }\n\n    if (this.async) {\n      this._readyStateChange(FakeXMLHttpRequest.DONE);\n    } else {\n      this.readyState = FakeXMLHttpRequest.DONE;\n    }\n  },\n\n  /*\n    Forces a response on to the FakeXMLHttpRequest object.\n\n    This is the public API for faking responses. This function\n    takes a number status, headers object, and string body:\n\n    ```\n    xhr.respond(404, {Content-Type: 'text/plain'}, \"Sorry. This object was not found.\")\n\n    ```\n  */\n  respond: function respond(status, headers, body) {\n    this._setResponseHeaders(headers || {});\n    this.status = typeof status == \"number\" ? status : 200;\n    this.statusText = httpStatusCodes[this.status];\n    this._setResponseBody(body || \"\");\n  }\n};\n\nfor (var property in FakeXMLHttpRequestProto) {\n  FakeXMLHttpRequest.prototype[property] = FakeXMLHttpRequestProto[property];\n}\n\nfunction verifyState(xhr) {\n  if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n    throw new Error(\"INVALID_STATE_ERR\");\n  }\n\n  if (xhr.sendFlag) {\n    throw new Error(\"INVALID_STATE_ERR\");\n  }\n}\n\n\nfunction verifyRequestSent(xhr) {\n    if (xhr.readyState == FakeXMLHttpRequest.DONE) {\n        throw new Error(\"Request done\");\n    }\n}\n\nfunction verifyHeadersReceived(xhr) {\n    if (xhr.async && xhr.readyState != FakeXMLHttpRequest.HEADERS_RECEIVED) {\n        throw new Error(\"No headers received\");\n    }\n}\n\nfunction verifyResponseBodyType(body) {\n    if (typeof body != \"string\") {\n        var error = new Error(\"Attempted to respond to fake XMLHttpRequest with \" +\n                             body + \", which is not a string.\");\n        error.name = \"InvalidBodyException\";\n        throw error;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FakeXMLHttpRequest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFrZS14bWwtaHR0cC1yZXF1ZXN0L3NyYy9mYWtlLXhtbC1odHRwLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMkJBQTJCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsa0JBQWtCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoZ28vLi9ub2RlX21vZHVsZXMvZmFrZS14bWwtaHR0cC1yZXF1ZXN0L3NyYy9mYWtlLXhtbC1odHRwLXJlcXVlc3QuanM/MzE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1pbmltYWwgRXZlbnQgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXG4gKlxuICogT3JpZ2luYWwgaW1wbGVtZW50YXRpb24gYnkgU3ZlbiBGdWNoczogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vOTk1MDI4XG4gKiBNb2RpZmljYXRpb25zIGFuZCB0ZXN0cyBieSBDaHJpc3RpYW4gSm9oYW5zZW4uXG4gKlxuICogQGF1dGhvciBTdmVuIEZ1Y2hzIChzdmVuZnVjaHNAYXJ0d2ViLWRlc2lnbi5kZSlcbiAqIEBhdXRob3IgQ2hyaXN0aWFuIEpvaGFuc2VuIChjaHJpc3RpYW5AY2pvaGFuc2VuLm5vKVxuICogQGxpY2Vuc2UgQlNEXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIFN2ZW4gRnVjaHMsIENocmlzdGlhbiBKb2hhbnNlblxuICovXG5cbnZhciBfRXZlbnQgPSBmdW5jdGlvbiBFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCB0YXJnZXQpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5idWJibGVzID0gYnViYmxlcztcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59O1xuXG5fRXZlbnQucHJvdG90eXBlID0ge1xuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHt9LFxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gIH1cbn07XG5cbi8qXG4gIFVzZWQgdG8gc2V0IHRoZSBzdGF0dXNUZXh0IHByb3BlcnR5IG9mIGFuIHhociBvYmplY3RcbiovXG52YXIgaHR0cFN0YXR1c0NvZGVzID0ge1xuICAxMDA6IFwiQ29udGludWVcIixcbiAgMTAxOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgMjAwOiBcIk9LXCIsXG4gIDIwMTogXCJDcmVhdGVkXCIsXG4gIDIwMjogXCJBY2NlcHRlZFwiLFxuICAyMDM6IFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcbiAgMjA0OiBcIk5vIENvbnRlbnRcIixcbiAgMjA1OiBcIlJlc2V0IENvbnRlbnRcIixcbiAgMjA2OiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICAzMDA6IFwiTXVsdGlwbGUgQ2hvaWNlXCIsXG4gIDMwMTogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICAzMDI6IFwiRm91bmRcIixcbiAgMzAzOiBcIlNlZSBPdGhlclwiLFxuICAzMDQ6IFwiTm90IE1vZGlmaWVkXCIsXG4gIDMwNTogXCJVc2UgUHJveHlcIixcbiAgMzA3OiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICA0MDA6IFwiQmFkIFJlcXVlc3RcIixcbiAgNDAxOiBcIlVuYXV0aG9yaXplZFwiLFxuICA0MDI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICA0MDM6IFwiRm9yYmlkZGVuXCIsXG4gIDQwNDogXCJOb3QgRm91bmRcIixcbiAgNDA1OiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICA0MDY6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgNDA3OiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gIDQwODogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgNDA5OiBcIkNvbmZsaWN0XCIsXG4gIDQxMDogXCJHb25lXCIsXG4gIDQxMTogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgNDEyOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgNDEzOiBcIlJlcXVlc3QgRW50aXR5IFRvbyBMYXJnZVwiLFxuICA0MTQ6IFwiUmVxdWVzdC1VUkkgVG9vIExvbmdcIixcbiAgNDE1OiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgNDE2OiBcIlJlcXVlc3RlZCBSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgNDE3OiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICA0MjI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgNTAwOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICA1MDE6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIDUwMjogXCJCYWQgR2F0ZXdheVwiLFxuICA1MDM6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICA1MDQ6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIDUwNTogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiXG59O1xuXG5cbi8qXG4gIENyb3NzLWJyb3dzZXIgWE1MIHBhcnNpbmcuIFVzZWQgdG8gdHVyblxuICBYTUwgcmVzcG9uc2VzIGludG8gRG9jdW1lbnQgb2JqZWN0c1xuICBCb3Jyb3dlZCBmcm9tIEpTcGVjXG4qL1xuZnVuY3Rpb24gcGFyc2VYTUwodGV4dCkge1xuICB2YXIgeG1sRG9jO1xuXG4gIGlmICh0eXBlb2YgRE9NUGFyc2VyICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJ0ZXh0L3htbFwiKTtcbiAgfSBlbHNlIHtcbiAgICB4bWxEb2MgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgeG1sRG9jLmFzeW5jID0gXCJmYWxzZVwiO1xuICAgIHhtbERvYy5sb2FkWE1MKHRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHhtbERvYztcbn1cblxuLypcbiAgV2l0aG91dCBtb2NraW5nLCB0aGUgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCB3aWxsIHRocm93XG4gIGFuIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBzZXQgdGhlc2UgaGVhZGVycy4gV2UgbWF0Y2ggdGhpcyBiZWhhdmlvci5cbiovXG52YXIgdW5zYWZlSGVhZGVycyA9IHtcbiAgXCJBY2NlcHQtQ2hhcnNldFwiOiB0cnVlLFxuICBcIkFjY2VwdC1FbmNvZGluZ1wiOiB0cnVlLFxuICBcIkNvbm5lY3Rpb25cIjogdHJ1ZSxcbiAgXCJDb250ZW50LUxlbmd0aFwiOiB0cnVlLFxuICBcIkNvb2tpZVwiOiB0cnVlLFxuICBcIkNvb2tpZTJcIjogdHJ1ZSxcbiAgXCJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nXCI6IHRydWUsXG4gIFwiRGF0ZVwiOiB0cnVlLFxuICBcIkV4cGVjdFwiOiB0cnVlLFxuICBcIkhvc3RcIjogdHJ1ZSxcbiAgXCJLZWVwLUFsaXZlXCI6IHRydWUsXG4gIFwiUmVmZXJlclwiOiB0cnVlLFxuICBcIlRFXCI6IHRydWUsXG4gIFwiVHJhaWxlclwiOiB0cnVlLFxuICBcIlRyYW5zZmVyLUVuY29kaW5nXCI6IHRydWUsXG4gIFwiVXBncmFkZVwiOiB0cnVlLFxuICBcIlVzZXItQWdlbnRcIjogdHJ1ZSxcbiAgXCJWaWFcIjogdHJ1ZVxufTtcblxuLypcbiAgQWRkcyBhbiBcImV2ZW50XCIgb250byB0aGUgZmFrZSB4aHIgb2JqZWN0XG4gIHRoYXQganVzdCBjYWxscyB0aGUgc2FtZS1uYW1lZCBtZXRob2QuIFRoaXMgaXNcbiAgaW4gY2FzZSBhIGxpYnJhcnkgYWRkcyBjYWxsYmFja3MgZm9yIHRoZXNlIGV2ZW50cy5cbiovXG5mdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHhocil7XG4gIHhoci5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGxpc3RlbmVyID0geGhyW1wib25cIiArIGV2ZW50TmFtZV07XG5cbiAgICBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbGlzdGVuZXIuY2FsbChldmVudC50YXJnZXQsIGV2ZW50KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBFdmVudGVkT2JqZWN0KCkge1xuICB0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuICB2YXIgZXZlbnRzID0gW1wibG9hZHN0YXJ0XCIsIFwicHJvZ3Jlc3NcIiwgXCJsb2FkXCIsIFwiYWJvcnRcIiwgXCJsb2FkZW5kXCJdO1xuICBmb3IgKHZhciBpID0gZXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnRzW2ldLCB0aGlzKTtcbiAgfVxufTtcblxuRXZlbnRlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3MgYWRkRXZlbnRMaXN0ZW5lciBmdW5jdGlvblxuICAqL1xuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSB8fCBbXTtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gIH0sXG5cbiAgLypcbiAgICBEdXBsaWNhdGVzIHRoZSBiZWhhdmlvciBvZiBuYXRpdmUgWE1MSHR0cFJlcXVlc3QncyByZW1vdmVFdmVudExpc3RlbmVyIGZ1bmN0aW9uXG4gICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PSBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICBEdXBsaWNhdGVzIHRoZSBiZWhhdmlvciBvZiBuYXRpdmUgWE1MSHR0cFJlcXVlc3QncyBkaXNwYXRjaEV2ZW50IGZ1bmN0aW9uXG4gICovXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgdHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzW2ldID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lcnNbaV0uaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gIH0sXG5cbiAgLypcbiAgICBUcmlnZ2VycyBhbiBgb25wcm9ncmVzc2AgZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgKi9cbiAgX3Byb2dyZXNzOiBmdW5jdGlvbiBfcHJvZ3Jlc3MobGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCkge1xuICAgIHZhciBldmVudCA9IG5ldyBfRXZlbnQoJ3Byb2dyZXNzJyk7XG4gICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcbiAgICBldmVudC5sZW5ndGhDb21wdXRhYmxlID0gbGVuZ3RoQ29tcHV0YWJsZTtcbiAgICBldmVudC5sb2FkZWQgPSBsb2FkZWQ7XG4gICAgZXZlbnQudG90YWwgPSB0b3RhbDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG5cbi8qXG4gIENvbnN0cnVjdG9yIGZvciBhIGZha2Ugd2luZG93LlhNTEh0dHBSZXF1ZXN0XG4qL1xuZnVuY3Rpb24gRmFrZVhNTEh0dHBSZXF1ZXN0KCkge1xuICBFdmVudGVkT2JqZWN0LmNhbGwodGhpcyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9IEZha2VYTUxIdHRwUmVxdWVzdC5VTlNFTlQ7XG4gIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB7fTtcbiAgdGhpcy5yZXF1ZXN0Qm9keSA9IG51bGw7XG4gIHRoaXMuc3RhdHVzID0gMDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gXCJcIjtcbiAgdGhpcy51cGxvYWQgPSBuZXcgRXZlbnRlZE9iamVjdCgpO1xuICB0aGlzLm9uYWJvcnQ9IG51bGw7XG4gIHRoaXMub25lcnJvcj0gbnVsbDtcbiAgdGhpcy5vbmxvYWQ9IG51bGw7XG4gIHRoaXMub25sb2FkZW5kPSBudWxsO1xuICB0aGlzLm9ubG9hZHN0YXJ0PSBudWxsO1xuICB0aGlzLm9ucHJvZ3Jlc3M9IG51bGw7XG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlPSBudWxsO1xuICB0aGlzLm9udGltZW91dD0gbnVsbDtcbn1cblxuRmFrZVhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSA9IG5ldyBFdmVudGVkT2JqZWN0KCk7XG5cbi8vIFRoZXNlIHN0YXR1cyBjb2RlcyBhcmUgYXZhaWxhYmxlIG9uIHRoZSBuYXRpdmUgWE1MSHR0cFJlcXVlc3Rcbi8vIG9iamVjdCwgc28gd2UgbWF0Y2ggdGhhdCBoZXJlIGluIGNhc2UgYSBsaWJyYXJ5IGlzIHJlbHlpbmcgb24gdGhlbS5cbkZha2VYTUxIdHRwUmVxdWVzdC5VTlNFTlQgPSAwO1xuRmFrZVhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCA9IDE7XG5GYWtlWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCA9IDI7XG5GYWtlWE1MSHR0cFJlcXVlc3QuTE9BRElORyA9IDM7XG5GYWtlWE1MSHR0cFJlcXVlc3QuRE9ORSA9IDQ7XG5cbnZhciBGYWtlWE1MSHR0cFJlcXVlc3RQcm90byA9IHtcbiAgVU5TRU5UOiAwLFxuICBPUEVORUQ6IDEsXG4gIEhFQURFUlNfUkVDRUlWRUQ6IDIsXG4gIExPQURJTkc6IDMsXG4gIERPTkU6IDQsXG4gIGFzeW5jOiB0cnVlLFxuICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuXG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3Mgb3BlbiBmdW5jdGlvblxuICAqL1xuICBvcGVuOiBmdW5jdGlvbiBvcGVuKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5hc3luYyA9IHR5cGVvZiBhc3luYyA9PSBcImJvb2xlYW5cIiA/IGFzeW5jIDogdHJ1ZTtcbiAgICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWU7XG4gICAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgdGhpcy5yZXNwb25zZVhNTCA9IG51bGw7XG4gICAgdGhpcy5yZXNwb25zZVVSTCA9IHVybDtcbiAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0ge307XG4gICAgdGhpcy5zZW5kRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWR5U3RhdGVDaGFuZ2UoRmFrZVhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCk7XG4gIH0sXG5cbiAgLypcbiAgICBEdXBsaWNhdGVzIHRoZSBiZWhhdmlvciBvZiBuYXRpdmUgWE1MSHR0cFJlcXVlc3QncyBzZXRSZXF1ZXN0SGVhZGVyIGZ1bmN0aW9uXG4gICovXG4gIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSkge1xuICAgIHZlcmlmeVN0YXRlKHRoaXMpO1xuXG4gICAgaWYgKHVuc2FmZUhlYWRlcnNbaGVhZGVyXSB8fCAvXihTZWMtfFByb3h5LSkvLnRlc3QoaGVhZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBcXFwiXCIgKyBoZWFkZXIgKyBcIlxcXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdEhlYWRlcnNbaGVhZGVyXSkge1xuICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVyc1toZWFkZXJdICs9IFwiLFwiICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgIER1cGxpY2F0ZXMgdGhlIGJlaGF2aW9yIG9mIG5hdGl2ZSBYTUxIdHRwUmVxdWVzdCdzIHNlbmQgZnVuY3Rpb25cbiAgKi9cbiAgc2VuZDogZnVuY3Rpb24gc2VuZChkYXRhKSB7XG4gICAgdmVyaWZ5U3RhdGUodGhpcyk7XG5cbiAgICBpZiAoIS9eKGdldHxoZWFkKSQvaS50ZXN0KHRoaXMubWV0aG9kKSkge1xuICAgICAgdmFyIGhhc0NvbnRlbnRUeXBlSGVhZGVyID0gZmFsc2VcblxuICAgICAgT2JqZWN0LmtleXModGhpcy5yZXF1ZXN0SGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICBoYXNDb250ZW50VHlwZUhlYWRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWhhc0NvbnRlbnRUeXBlSGVhZGVyICYmICEoZGF0YSB8fCAnJykudG9TdHJpbmcoKS5tYXRjaCgnRm9ybURhdGEnKSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXF1ZXN0Qm9keSA9IGRhdGE7XG4gICAgfVxuXG4gICAgdGhpcy5lcnJvckZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLnNlbmRGbGFnID0gdGhpcy5hc3luYztcbiAgICB0aGlzLl9yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5PUEVORUQpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uU2VuZCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMub25TZW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgX0V2ZW50KFwibG9hZHN0YXJ0XCIsIGZhbHNlLCBmYWxzZSwgdGhpcykpO1xuICB9LFxuXG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3MgYWJvcnQgZnVuY3Rpb25cbiAgKi9cbiAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBudWxsO1xuICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlVGV4dDtcbiAgICB0aGlzLmVycm9yRmxhZyA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHt9O1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBfRXZlbnQoXCJhYm9ydFwiLCBmYWxzZSwgZmFsc2UsIHRoaXMpKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiBGYWtlWE1MSHR0cFJlcXVlc3QuVU5TRU5UICYmIHRoaXMuc2VuZEZsYWcpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGVDaGFuZ2UoRmFrZVhNTEh0dHBSZXF1ZXN0LlVOU0VOVCk7XG4gICAgICB0aGlzLnNlbmRGbGFnID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5vbmVycm9yKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3MgZ2V0UmVzcG9uc2VIZWFkZXIgZnVuY3Rpb25cbiAgKi9cbiAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPCBGYWtlWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKC9eU2V0LUNvb2tpZTI/JC9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBmb3IgKHZhciBoIGluIHRoaXMucmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICBpZiAoaC50b0xvd2VyQ2FzZSgpID09IGhlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUhlYWRlcnNbaF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLypcbiAgICBEdXBsaWNhdGVzIHRoZSBiZWhhdmlvciBvZiBuYXRpdmUgWE1MSHR0cFJlcXVlc3QncyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgZnVuY3Rpb25cbiAgKi9cbiAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiBnZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA8IEZha2VYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVycyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBoZWFkZXIgaW4gdGhpcy5yZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgIGlmICh0aGlzLnJlc3BvbnNlSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpICYmICEvXlNldC1Db29raWUyPyQvaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgaGVhZGVycyArPSBoZWFkZXIgKyBcIjogXCIgKyB0aGlzLnJlc3BvbnNlSGVhZGVyc1toZWFkZXJdICsgXCJcXHJcXG5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSxcblxuICAvKlxuICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3Mgb3ZlcnJpZGVNaW1lVHlwZSBmdW5jdGlvblxuICAgKi9cbiAgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gb3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSkge1xuICAgIGlmICh0eXBlb2YgbWltZVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuZm9yY2VNaW1lVHlwZSA9IG1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLypcbiAgICBQbGFjZXMgYSBGYWtlWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IGludG8gdGhlIHBhc3NlZFxuICAgIHN0YXRlLlxuICAqL1xuICBfcmVhZHlTdGF0ZUNoYW5nZTogZnVuY3Rpb24gX3JlYWR5U3RhdGVDaGFuZ2Uoc3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZShuZXcgX0V2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKSk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBfRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gRmFrZVhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgX0V2ZW50KFwibG9hZFwiLCBmYWxzZSwgZmFsc2UsIHRoaXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSBGYWtlWE1MSHR0cFJlcXVlc3QuVU5TRU5UIHx8IHRoaXMucmVhZHlTdGF0ZSA9PSBGYWtlWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBfRXZlbnQoXCJsb2FkZW5kXCIsIGZhbHNlLCBmYWxzZSwgdGhpcykpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qXG4gICAgU2V0cyB0aGUgRmFrZVhNTEh0dHBSZXF1ZXN0IG9iamVjdCdzIHJlc3BvbnNlIGhlYWRlcnMgYW5kXG4gICAgcGxhY2VzIHRoZSBvYmplY3QgaW50byByZWFkeVN0YXRlIDJcbiAgKi9cbiAgX3NldFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gX3NldFJlc3BvbnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSB7fTtcblxuICAgIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG4gICAgICAgICAgdGhpcy5yZXNwb25zZUhlYWRlcnNbaGVhZGVyXSA9IGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5mb3JjZU1pbWVUeXBlKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlSGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLmZvcmNlTWltZVR5cGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXN5bmMpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGVDaGFuZ2UoRmFrZVhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBGYWtlWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRDtcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICBTZXRzIHRoZSBGYWtlWE1MSHR0cFJlcXVlc3Qgb2JqZWN0J3MgcmVzcG9uc2UgYm9keSBhbmRcbiAgICBpZiBib2R5IHRleHQgaXMgWE1MLCBzZXRzIHJlc3BvbnNlWE1MIHRvIHBhcnNlZCBkb2N1bWVudFxuICAgIG9iamVjdFxuICAqL1xuICBfc2V0UmVzcG9uc2VCb2R5OiBmdW5jdGlvbiBfc2V0UmVzcG9uc2VCb2R5KGJvZHkpIHtcbiAgICB2ZXJpZnlSZXF1ZXN0U2VudCh0aGlzKTtcbiAgICB2ZXJpZnlIZWFkZXJzUmVjZWl2ZWQodGhpcyk7XG4gICAgdmVyaWZ5UmVzcG9uc2VCb2R5VHlwZShib2R5KTtcblxuICAgIHZhciBjaHVua1NpemUgPSB0aGlzLmNodW5rU2l6ZSB8fCAxMDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZVRleHQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5hc3luYykge1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5MT0FESU5HKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNwb25zZVRleHQgKz0gYm9keS5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgY2h1bmtTaXplKTtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlVGV4dDtcbiAgICAgIGluZGV4ICs9IGNodW5rU2l6ZTtcbiAgICB9IHdoaWxlIChpbmRleCA8IGJvZHkubGVuZ3RoKTtcblxuICAgIHZhciB0eXBlID0gdGhpcy5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcblxuICAgIGlmICh0aGlzLnJlc3BvbnNlVGV4dCAmJiAoIXR5cGUgfHwgLyh0ZXh0XFwveG1sKXwoYXBwbGljYXRpb25cXC94bWwpfChcXCt4bWwpLy50ZXN0KHR5cGUpKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVhNTCA9IHBhcnNlWE1MKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVW5hYmxlIHRvIHBhcnNlIFhNTCAtIG5vIGJpZ2dpZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5ET05FKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gRmFrZVhNTEh0dHBSZXF1ZXN0LkRPTkU7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAgRm9yY2VzIGEgcmVzcG9uc2Ugb24gdG8gdGhlIEZha2VYTUxIdHRwUmVxdWVzdCBvYmplY3QuXG5cbiAgICBUaGlzIGlzIHRoZSBwdWJsaWMgQVBJIGZvciBmYWtpbmcgcmVzcG9uc2VzLiBUaGlzIGZ1bmN0aW9uXG4gICAgdGFrZXMgYSBudW1iZXIgc3RhdHVzLCBoZWFkZXJzIG9iamVjdCwgYW5kIHN0cmluZyBib2R5OlxuXG4gICAgYGBgXG4gICAgeGhyLnJlc3BvbmQoNDA0LCB7Q29udGVudC1UeXBlOiAndGV4dC9wbGFpbid9LCBcIlNvcnJ5LiBUaGlzIG9iamVjdCB3YXMgbm90IGZvdW5kLlwiKVxuXG4gICAgYGBgXG4gICovXG4gIHJlc3BvbmQ6IGZ1bmN0aW9uIHJlc3BvbmQoc3RhdHVzLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgdGhpcy5fc2V0UmVzcG9uc2VIZWFkZXJzKGhlYWRlcnMgfHwge30pO1xuICAgIHRoaXMuc3RhdHVzID0gdHlwZW9mIHN0YXR1cyA9PSBcIm51bWJlclwiID8gc3RhdHVzIDogMjAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGh0dHBTdGF0dXNDb2Rlc1t0aGlzLnN0YXR1c107XG4gICAgdGhpcy5fc2V0UmVzcG9uc2VCb2R5KGJvZHkgfHwgXCJcIik7XG4gIH1cbn07XG5cbmZvciAodmFyIHByb3BlcnR5IGluIEZha2VYTUxIdHRwUmVxdWVzdFByb3RvKSB7XG4gIEZha2VYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGVbcHJvcGVydHldID0gRmFrZVhNTEh0dHBSZXF1ZXN0UHJvdG9bcHJvcGVydHldO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZSh4aHIpIHtcbiAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSBGYWtlWE1MSHR0cFJlcXVlc3QuT1BFTkVEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gIH1cblxuICBpZiAoeGhyLnNlbmRGbGFnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB2ZXJpZnlSZXF1ZXN0U2VudCh4aHIpIHtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gRmFrZVhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBkb25lXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmVyaWZ5SGVhZGVyc1JlY2VpdmVkKHhocikge1xuICAgIGlmICh4aHIuYXN5bmMgJiYgeGhyLnJlYWR5U3RhdGUgIT0gRmFrZVhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGVhZGVycyByZWNlaXZlZFwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVJlc3BvbnNlQm9keVR5cGUoYm9keSkge1xuICAgIGlmICh0eXBlb2YgYm9keSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZXNwb25kIHRvIGZha2UgWE1MSHR0cFJlcXVlc3Qgd2l0aCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKyBcIiwgd2hpY2ggaXMgbm90IGEgc3RyaW5nLlwiKTtcbiAgICAgICAgZXJyb3IubmFtZSA9IFwiSW52YWxpZEJvZHlFeGNlcHRpb25cIjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgRmFrZVhNTEh0dHBSZXF1ZXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fake-xml-http-request/src/fake-xml-http-request.js\n");

/***/ })

};
;